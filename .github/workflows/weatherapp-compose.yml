name: CI - WeatherApp (Docker Compose)

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  compose:
    runs-on:
      group: Wesley-group-runner

    env:
      MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
      REDIS_USER: ${{ secrets.REDIS_USER }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
      WEATHER_APIKEY: ${{ secrets.WEATHER_APIKEY }}
      DB_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
      ERIC: eric
      AUTH_DB_NAME: ${{ secrets.AUTH_DB_NAME }} # leave empty if you want the default "authdb"

    steps:
      # âœ… NEW: clean leftover root-owned files before checkout so actions/checkout won't fail
      - name: Pre-checkout cleanup (remove workspace leftovers)
        run: |
          set +e
          echo "Cleaning $GITHUB_WORKSPACE top-level contents (if any)..."
          # Try to remove known bind-mounted dirs first (from earlier runs)
          (sudo rm -rf "$GITHUB_WORKSPACE/redis-data" || rm -rf "$GITHUB_WORKSPACE/redis-data") 2>/dev/null || true
          (sudo rm -rf "$GITHUB_WORKSPACE/db-data"    || rm -rf "$GITHUB_WORKSPACE/db-data") 2>/dev/null || true
          # Fallback: clear everything at top level (ignore errors if root-owned)
          if command -v sudo >/dev/null 2>&1; then
            sudo find "$GITHUB_WORKSPACE" -mindepth 1 -maxdepth 1 -exec rm -rf {} + || true
          else
            rm -rf "$GITHUB_WORKSPACE"/* "$GITHUB_WORKSPACE"/.[!.]* "$GITHUB_WORKSPACE"/..?* 2>/dev/null || true
          fi
          # Ensure workspace is writable by the runner user
          (sudo chown -R "$USER":"$USER" "$GITHUB_WORKSPACE" || true) 2>/dev/null
          set -e

      - name: Checkout repository (no aggressive clean)
        uses: actions/checkout@v4
        with:
          clean: false
          fetch-depth: 0

      - name: Show runner info
        run: |
          echo "Runner: ${{ runner.name }}"
          echo "Repo: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Runner group: Wesley-group-runner"

      - name: Verify Docker & Compose
        run: |
          docker version
          docker compose version || docker-compose --version || true

      - name: Generate docker-compose file (named volumes)
        run: |
          cat > docker-compose.ci.yml <<'YML'
          version: '3.5'
          services:
            db:
              container_name: weatherapp-db
              image: bulawesley/db:v1
              environment:
                MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
              volumes:
                - db-data:/var/lib/mysql
              networks: [ weatherapp ]
              restart: always

            redis:
              container_name: weatherapp-redis
              image: bulawesley/redis:v1
              environment:
                REDIS_USER: ${REDIS_USER:-redis}
                REDIS_PASSWORD: ${REDIS_PASSWORD:-redis}
              volumes:
                - redis-data:/data
              networks: [ weatherapp ]
              restart: always

            weather:
              container_name: weatherapp-weather
              image: bulawesley/weather:v1
              environment:
                APIKEY: ${WEATHER_APIKEY}
              expose: [ "5000" ]
              depends_on: [ db, redis ]
              networks: [ weatherapp ]
              restart: always

            auth:
              container_name: weatherapp-auth
              image: bulawesley/auth:v1
              environment:
                DB_HOST: db
                DB_PASSWORD: ${DB_PASSWORD}
              expose: [ "8080" ]
              depends_on: [ weather ]
              networks: [ weatherapp ]
              restart: always

            ui:
              container_name: weatherapp-ui
              image: bulawesley/ui:v1
              environment:
                eric: ${ERIC}
                AUTH_HOST: auth
                AUTH_PORT: "8080"
                WEATHER_HOST: weather
                WEATHER_PORT: "5000"
                REDIS_USER: ${REDIS_USER:-redis}
                REDIS_PASSWORD: ${REDIS_PASSWORD:-redis}
              expose: [ "3000" ]
              ports: [ "3000:3000" ]
              depends_on: [ auth ]
              networks: [ weatherapp ]
              restart: always

          networks:
            weatherapp: {}

          volumes:
            db-data: {}
            redis-data: {}
          YML

      - name: Pre-cleanup (best effort)
        run: docker compose -f docker-compose.ci.yml down -v || true

      - name: Pull images
        run: docker compose -f docker-compose.ci.yml pull

      - name: Start stack
        run: docker compose -f docker-compose.ci.yml up -d

      - name: Wait for containers to start
        run: |
          echo "Waiting for services to initialize..."
          sleep 15
          docker ps

      - name: UI smoke test (:3000)
        run: |
          echo "Checking UI on http://localhost:3000 ..."
          for i in {1..30}; do
            if curl -fsS http://localhost:3000/ >/dev/null 2>&1; then
              echo "UI is responding on :3000"
              exit 0
            fi
            echo "Waiting... ($i/30)"; sleep 2
          done
          echo "UI failed to respond on :3000"
          docker compose -f docker-compose.ci.yml logs --no-color
          exit 1

      - name: Display external VM IP and open ports
        run: |
          EXTERNAL_IP=$(curl -s ifconfig.me || curl -s https://api.ipify.org || echo "unknown")
          echo "========================================================"
          echo "External IP: $EXTERNAL_IP"
          echo "Open in your browser (ensure GCP firewall allows tcp:3000):"
          echo "  http://$EXTERNAL_IP:3000"
          echo "========================================================"
          (ss -tuln || netstat -tuln) | grep -E '(:3000|:8080|:5000)' || true

      # ---------- Hardening: DB constraint + test (YAML-safe) ----------
      - name: Wait for MySQL to be ready
        run: |
          echo "Waiting for MySQL..."
          for i in {1..60}; do
            if docker exec weatherapp-db mysqladmin -uroot -p"$MYSQL_ROOT_PASSWORD" ping --silent; then
              echo "MySQL is ready"; exit 0
            fi
            sleep 2
          done
          echo "MySQL did not become ready in time"; exit 1

      - name: Prepare SQL migration file
        shell: bash
        run: |
          DBNAME="${AUTH_DB_NAME:-authdb}"
          echo "Using auth DB: $DBNAME"
          cat > /tmp/migrate_username_norm.sql <<'SQL'
          SET @db  = DATABASE(); -- will be replaced below
          SET @tbl = 'users';
          SET @col = 'username_norm';
          SET @idx = 'users_username_norm_uq';

          -- Create generated column if missing
          SELECT IF(
            EXISTS(
              SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS
              WHERE TABLE_SCHEMA=@db AND TABLE_NAME=@tbl AND COLUMN_NAME=@col
            ),
            'SELECT 1',
            CONCAT('ALTER TABLE ', @db, '.', @tbl,
                   ' ADD COLUMN ', @col,
                   ' VARCHAR(191) GENERATED ALWAYS AS (LOWER(TRIM(username))) STORED')
          ) INTO @sql1;
          PREPARE s1 FROM @sql1; EXECUTE s1; DEALLOCATE PREPARE s1;

          -- Create UNIQUE index if missing
          SELECT IF(
            EXISTS(
              SELECT 1 FROM INFORMATION_SCHEMA.STATISTICS
              WHERE TABLE_SCHEMA=@db AND TABLE_NAME=@tbl AND INDEX_NAME=@idx
            ),
            'SELECT 1',
            CONCAT('CREATE UNIQUE INDEX ', @idx,
                   ' ON ', @db, '.', @tbl, ' (', @col, ')')
          ) INTO @sql2;
          PREPARE s2 FROM @sql2; EXECUTE s2; DEALLOCATE PREPARE s2;
          SQL
          # Replace the first line to set @db = '$DBNAME';
          sed -i "1s|.*|SET @db = '${DBNAME}';|" /tmp/migrate_username_norm.sql

      - name: Run SQL migration
        run: |
          docker exec -i weatherapp-db mysql -uroot -p"$MYSQL_ROOT_PASSWORD" < /tmp/migrate_username_norm.sql

      - name: Flush Redis cache (avoid stale 'exists' results)
        run: |
          docker exec weatherapp-redis redis-cli -a "$REDIS_PASSWORD" FLUSHALL || \
          docker exec weatherapp-redis redis-cli FLUSHALL || true

      - name: Signup uniqueness test (first OK, second rejected)
        run: |
          # First signup (expect 2xx)
          CODE1=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8080/api/signup \
            -H "Content-Type: application/json" \
            -d '{"username":"ci_test_user","email":"ci_test_user@example.com","password":"P@ssw0rd!"}')
          echo "First signup HTTP $CODE1"
          if [ "$CODE1" -lt 200 ] || [ "$CODE1" -ge 300 ]; then
            echo "Expected first signup to succeed (2xx)"; exit 1
          fi

          # Duplicate signup (expect non-2xx)
          CODE2=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8080/api/signup \
            -H "Content-Type: application/json" \
            -d '{"username":"ci_test_user","email":"ci_test_user2@example.com","password":"P@ssw0rd!"}')
          echo "Duplicate signup HTTP $CODE2"
          if [ "$CODE2" -ge 200 ] && [ "$CODE2" -lt 300 ]; then
            echo "Expected duplicate signup to be rejected (409 or non-2xx)"; exit 1
          fi
          echo "Username uniqueness enforced (case-insensitive, trim-safe)"

      - name: Keep stack running for 3 minutes
        run: |
          echo "Application will remain up for 3 minutes before teardown..."
          echo "If you haven't already, open: http://$(curl -s ifconfig.me || echo localhost):3000"
          sleep 180

      - name: Teardown stack
        if: always()
        run: |
          echo "Bringing down the stack..."
          docker compose -f docker-compose.ci.yml down -v || true
          echo "Stack removed"
